#### 1.redux

createStore： 创建实例
reducer： 存储数据的对象
dispatch： 更新数据
subscribe： 订阅发生state发生改变
getState： 获取数据

```js
const counterReducer = (state = 0, action) => {
    switch(action.type) {
        case "add":
            return state + 1
        case 'minus':
            return state - 1
        default: 
            return state
    }
}

const store = createStore(counterReducer)

class ReduxTest extends Component {
    componentDidMount() {
        //state发生更改订阅作对应的刷新
        store.subscribe(() => {
            this.forceUpdate()
        })
    }
    render() {
        return (
            <div>
                <p>{store.getState()}</p>
                <button onClick={() => store.dispatch({type: 'add'})}>+</button>
                <button onClick={() => store.dispatch({type: 'minus'})}>-</button>
            </div>
        )
    }
}
```

redux操作数据变更比较麻烦， 数据变更之后又要订阅进行重新渲染。所以就出来了react-redux 	



#### 2. react-redux

1. 全局提供store, 供后面组件使用

   ```
   <Provider store={store}> <App/> </Provider>,
   ```

2. 提供connext 装饰器 

   ```js
   @connect( 
     state => ({ num: state }), // 状态映射 
     { 
       add: () => ({ type: "add" }), // action creator 
      	minus: () => ({ type: "minus" }) // action creator 
     } 
   )
   //装饰之后 数据都放进去 props 和 store看起来没有关联了。 解耦了
   // ReduxTest 又成了一个简单单一的组件
   class ReduxTest extends Component {
       render() {
           return (
               <div>
                   <p>{this.props.num}</p>
                   <button onClick={this.props.add}>+</button>
                   <button onClick={this.props.minus}>-</button>
               </div>
           )
       }
   }
   ```

   

